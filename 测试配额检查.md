# 配额检查测试清单

## 📋 测试步骤

### 步骤 1: 验证数据库函数已正确部署

在 Supabase SQL 编辑器中运行以下 SQL：

```sql
-- 1. 检查函数是否存在且使用了 SECURITY DEFINER
SELECT 
  proname as function_name,
  prosecdef as is_security_definer,
  pg_get_functiondef(oid) as function_definition
FROM pg_proc 
WHERE proname = 'check_user_conversation_quota';
```

**预期结果**：
- `is_security_definer` 应该为 `true`（t）
- 函数定义应该包含 `SECURITY DEFINER`

### 步骤 2: 测试数据库函数的逻辑

```sql
-- 假设您的用户ID和botID（请替换为实际值）
-- 可以从浏览器控制台运行：const { user } = useSupabase(); console.log(user.value.id)

-- 测试场景1: 使用量 < 配额（应该返回 true）
-- 首先设置一个测试配额和使用量
-- 注意：这个测试需要您手动设置测试数据

-- 测试场景2: 使用量 >= 配额（应该返回 false）
SELECT check_user_conversation_quota(
  '您的用户ID'::UUID,
  '您的botID'::UUID
);
```

**预期结果**：
- 如果使用量 14 >= 配额 10，应该返回 `false`
- 如果使用量 < 配额，应该返回 `true`

### 步骤 3: 检查数据库数据

```sql
-- 检查配额设置
SELECT 
  id,
  user_id,
  bot_id,
  max_conversations,
  max_tokens,
  created_at
FROM user_quotas 
WHERE user_id = '您的用户ID'::UUID
ORDER BY bot_id NULLS LAST;

-- 检查使用量统计
SELECT 
  id,
  user_id,
  bot_id,
  conversation_count,
  token_count,
  period_start,
  period_end,
  updated_at
FROM usage_metrics 
WHERE user_id = '您的用户ID'::UUID
  AND period_start = date_trunc('month', CURRENT_DATE)::DATE
ORDER BY bot_id NULLS LAST;
```

**确认点**：
- ✅ 配额是否正确（应该是 10）
- ✅ 使用量是否正确（应该是 14）
- ✅ 日期范围是否正确（当前月份）

### 步骤 4: 在浏览器控制台中测试

打开浏览器开发者工具（F12），在 Console 标签页中运行以下代码：

```javascript
// 测试配额检查函数
(async function testQuotaCheck() {
  try {
    // 导入必要的模块（根据您的项目结构调整导入路径）
    const { useSupabase } = await import('/src/composables/useSupabase.js');
    const { usageService } = await import('/src/services/usageService.js');
    const { botService } = await import('/src/services/botService.js');
    
    const { user, supabase } = useSupabase();
    
    if (!user.value) {
      console.error('❌ 用户未登录');
      return;
    }
    
    console.log('✅ 用户已登录:', user.value.id);
    
    // 获取数智人列表
    const { data: bots } = await botService.getBots();
    if (!bots || bots.length === 0) {
      console.error('❌ 无法获取数智人列表');
      return;
    }
    
    const testBot = bots[0];
    console.log('✅ 测试数智人:', testBot.id, testBot.coze_bot_id);
    
    // 测试1: 直接调用数据库函数
    console.log('\n📊 测试1: 直接调用数据库函数');
    const { data: dbResult, error: dbError } = await supabase
      .rpc('check_user_conversation_quota', {
        p_user_id: user.value.id,
        p_bot_id: testBot.id
      });
    
    console.log('数据库函数结果:', {
      data: dbResult,
      error: dbError,
      type: typeof dbResult,
      isTrue: dbResult === true,
      isFalse: dbResult === false
    });
    
    // 测试2: 通过服务调用
    console.log('\n📊 测试2: 通过配额检查服务');
    const checkResult = await usageService.checkConversationQuota(
      user.value.id,
      testBot.id
    );
    
    console.log('配额检查服务结果:', checkResult);
    
    // 测试3: 验证逻辑
    console.log('\n📊 测试3: 验证逻辑');
    console.log('数据库函数返回:', dbResult);
    console.log('服务返回 allowed:', checkResult.allowed);
    console.log('是否一致:', (dbResult === true) === checkResult.allowed);
    
    // 测试4: 检查数据
    console.log('\n📊 测试4: 检查数据库数据');
    
    // 检查配额
    const { data: quota } = await supabase
      .from('user_quotas')
      .select('*')
      .eq('user_id', user.value.id)
      .eq('bot_id', testBot.id)
      .single();
    
    if (!quota) {
      const { data: globalQuota } = await supabase
        .from('user_quotas')
        .select('*')
        .eq('user_id', user.value.id)
        .is('bot_id', null)
        .single();
      
      console.log('全局配额:', globalQuota);
    } else {
      console.log('数智人配额:', quota);
    }
    
    // 检查使用量
    const monthStart = new Date();
    monthStart.setDate(1);
    monthStart.setHours(0, 0, 0, 0);
    
    const monthEnd = new Date(monthStart);
    monthEnd.setMonth(monthEnd.getMonth() + 1);
    monthEnd.setDate(0);
    
    const { data: usage } = await supabase
      .from('usage_metrics')
      .select('*')
      .eq('user_id', user.value.id)
      .eq('bot_id', testBot.id)
      .eq('period_start', monthStart.toISOString().split('T')[0])
      .eq('period_end', monthEnd.toISOString().split('T')[0])
      .single();
    
    console.log('使用量统计:', usage);
    
    // 总结
    console.log('\n📊 测试总结:');
    console.log('='.repeat(50));
    const maxQuota = quota?.max_conversations ?? -1;
    const currentUsage = usage?.conversation_count ?? 0;
    
    console.log('配额限制:', maxQuota === -1 ? '无限制' : maxQuota);
    console.log('当前使用量:', currentUsage);
    
    if (maxQuota !== -1) {
      if (currentUsage >= maxQuota) {
        console.log('状态: ❌ 已超过配额');
        console.log('数据库函数应该返回: false');
        console.log('数据库函数实际返回:', dbResult);
        console.log('服务应该返回 allowed: false');
        console.log('服务实际返回 allowed:', checkResult.allowed);
        
        if (dbResult !== false) {
          console.error('⚠️ 问题: 数据库函数应该返回 false，但返回了', dbResult);
        }
        if (checkResult.allowed !== false) {
          console.error('⚠️ 问题: 服务应该返回 allowed: false，但返回了', checkResult.allowed);
        }
      } else {
        console.log('状态: ✅ 未超过配额');
        console.log('数据库函数应该返回: true');
        console.log('数据库函数实际返回:', dbResult);
      }
    }
    console.log('='.repeat(50));
    
  } catch (error) {
    console.error('❌ 测试出错:', error);
  }
})();
```

### 步骤 5: 实际发送消息测试

1. 打开应用，确保用户已登录
2. 打开浏览器开发者工具（F12）→ Console 标签页
3. 尝试发送一条消息
4. 观察控制台日志，查找：
   - `[配额检查]` 开头的日志
   - `[消息发送]` 开头的日志
5. 检查消息是否被阻止

**预期行为**：
- 如果使用量 >= 配额，应该看到：
  - `[配额检查] ❌ 配额检查未通过`
  - `[消息发送] ❌ 配额检查未通过，立即阻止消息发送`
  - 弹出提示："您已达到本月对话次数限制..."
  - 消息**不应该**发送成功

## 🔍 问题排查

### 如果测试失败，检查以下项目：

1. **数据库函数未正确部署**
   - 运行 `fix_check_user_conversation_quota_function.sql`
   - 确认 `prosecdef = true`

2. **数据不同步**
   - 检查 `usage_metrics.conversation_count` 是否准确
   - 检查 `user_quotas.max_conversations` 是否准确
   - 检查日期范围是否正确（当前月份）

3. **代码未更新**
   - 确认代码已重新编译/构建
   - 清除浏览器缓存
   - 硬刷新页面（Ctrl+Shift+R 或 Cmd+Shift+R）

4. **有多个代码路径**
   - 确认所有消息发送都通过 `sendMessageWithBot` 或 `useGspChatStore.sendMessage`
   - 检查是否有其他发送消息的方式

## ✅ 测试通过标准

- ✅ 数据库函数返回 `false`（当使用量 >= 配额时）
- ✅ 配额检查服务返回 `allowed: false`
- ✅ 消息发送被阻止（返回 `null`）
- ✅ 显示错误提示
- ✅ 控制台日志显示正确的检查结果
